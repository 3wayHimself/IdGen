<?xml version="1.0" encoding="utf-8"?>
<topic id="3a4a831b-1e7b-4e68-b614-319e3097162a" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <introduction>
      <para>
        Twitter Snowflake-alike ID generator for .Net. Available as
        <externalLink>
          <linkText>Nuget package</linkText>
          <linkUri>https://www.nuget.org/packages/IdGen</linkUri>
        </externalLink>.
      </para>
    </introduction>

    <section>
      <title>Why</title>
      <content>
        <para>
          In certain situations you need a low-latency uncoordinated, (roughly) time ordered, compact and highly available Id generation system. This project was inspired by
          <externalLink>
            <linkText>Twitter's Snowflake</linkText>
            <linkUri>https://github.com/twitter/snowflake</linkUri>
          </externalLink>
          project which has been retired. Note that this project was inspired by Snowflake but is not an exact implementation. This library provides a basis for Id generation; it does <legacyBold>not</legacyBold> provide a service for handing out these Id's nor does it provide generator-id ('worker-id') coordination.
        </para>
      </content>
    </section>

    <section>
      <title>How it works</title>
      <content>
        <para>
          IdGen generates, like Snowflake, 64 bit Id's. The
          <externalLink>
            <linkText>Sign Bit</linkText>
            <linkUri>https://en.wikipedia.org/wiki/Sign_bit</linkUri>
          </externalLink>
          is unused since this can cause incorrect ordering on some systems that cannot use unsigned types and/or make it hard to get correct ordering. So, in effect, IdGen generates 63 bit Id's. An Id consists of 3 parts:
        </para>
        <list class="bullet">
          <listItem>
            <para>Timestamp</para>
          </listItem>
          <listItem>
            <para>Generator-id</para>
          </listItem>
          <listItem>
            <para>Sequence</para>
          </listItem>
        </list>
        <para>
          An Id generated with a <codeEntityReference linkText="Default MaskConfig">P:IdGen.MaskConfig.Default</codeEntityReference> is structured as follows:
        </para>
        <mediaLink>
          <image xlink:href="structure"/>
        </mediaLink>

        <para>
          However, using the <codeEntityReference linkText="MaskConfig">T:IdGen.MaskConfig</codeEntityReference> class you can tune the structure of the created Id's to your own needs; you can use 45 bits for the timestamp (â‰ˆ1114 years), 2 bits for the generator-id and 16 bits for the sequence to allow, for example, generating 65536 id's per millisecond per generator distributed over 4 hosts/threads giving you a total of 262144 id's per millisecond. As long as all 3 parts (timestamp, generator and sequence) add up to 63 bits you're good to go!
        </para>
        <para>
          The <legacyBold>timestamp</legacyBold>-part of the Id should speak for itselft; this is incremented every millisecond and represents the number of milliseconds since a certain epoch. By default IdGen uses 2015-01-01 0:00:00Z as epoch, but you can specify a custom epoch.
        </para>
        <para>
          The <legacyBold>generator-id</legacyBold>-part of the Id is the part that you 'configure'; it could correspond to a host, thread, datacenter or continent: it's up to you. However, the generator-id should be unique in the system: if you have several hosts generating Id's, each host should have it's own generator-id. This could be based on the hostname, a config-file value or even be retrieved from an coordinating service. Remember: a generator-id should be unique within the entire system to avoid collisions!
        </para>
        <para>
          The <legacyBold>sequence</legacyBold>-part is simply a value that is incremented each time a new Id is generated within the same millisecond timespan; it is reset every time the timestamp changes. Speaking of this:
        </para>
      </content>
    </section>

    <section>
      <title>System Clock Dependency</title>
      <content>
        <para>
          We recommend you use NTP to keep your system clock accurate. IdGen protects from non-monotonic clocks, i.e. clocks that run backwards. If your clock is running fast and NTP tells it to repeat a few milliseconds, IdGen will refuse to generate Id's until a time that is after the last time IdGen generated an Id. Whenever possible, run in a mode where NTP won't correct the clock backwards. See
          <externalLink>
            <linkText>Time synchronization</linkText>
            <linkUri>http://wiki.dovecot.org/TimeMovedBackwards#Time_synchronization</linkUri>
          </externalLink>
          for tips on how to do this.
        </para>
      </content>
    </section>

    <section>
      <title>Getting started</title>
      <content>
        <para>
          Install the
          <externalLink>
            <linkText>Nuget package</linkText>
            <linkUri>https://www.nuget.org/packages/IdGen</linkUri>
          </externalLink>
          and write the following code:
        </para>
        <code language="cs">
          <![CDATA[
            using IdGen;
            using System.Linq;

            class Program
            {
                static void Main(string[] args)
                {
                    var generator = new IdGenerator(0);
                    var id = generator.CreateId();
                }
            }
        ]]>
        </code>
        <para>Voila. You have created your first Id! Want to create 100 Id's? Instead of:</para>
        <code language="cs">
          <![CDATA[
            var id = generator.CreateId();
          ]]>
        </code>
        <para>write:</para>
        <code language="cs">
          <![CDATA[
            var id = generator.Take(100);
          ]]>
        </code>
        <para>
          This is because the <codeEntityReference linkText="IdGenerator">T:IdGen.IdGenerator</codeEntityReference> implements <codeEntityReference linkText="IEnumerable">T:System.Collections.IEnumerable</codeEntityReference> providing you with a never-ending stream of Id's (so you might want to be careful doing a <codeInline>.Select(...)</codeInline> on it!).
        </para>
        <para>
          The above example creates a default <codeEntityReference linkText="IdGenerator">T:IdGen.IdGenerator</codeEntityReference> with the <codeEntityReference linkText="GeneratorId">P:IdGen.IdGenerator.Id</codeEntityReference> (or: 'Worker Id') set to 0. If you're using multiple generators (across machines or in separate threads or...) you'll want to make sure each generator is assigned it's own unique Id. One way of doing this is by simply storing a value in your configuration file for example, another way may involve a service handing out GeneratorId's to machines/threads. IdGen <legacyBold>does not</legacyBold> provide a solution for this since each project or setup may have different requirements or infrastructure to provide these generator-id's.
        </para>
        <para>
          The below sample is a bit more complicated; we set a custom epoch, define our own (bit)mask configuration for generated Id's and then display some information about the setup:
        </para>
        <code language="cs">
          <![CDATA[
            using IdGen;
            using System;

            class Program
            {
                static void Main(string[] args)
                {
                    // Let's say we take april 1st 2015 as our epoch
                    var epoch = new DateTime(2015, 4, 1, 0, 0, 0, DateTimeKind.Utc);
                    // Create a mask configuration of 45 bits for timestamp, 2 for generator-id 
                    // and 16 for sequence
                    var mc = new MaskConfig(45, 2, 16);
                    // Create an IdGenerator with it's generator-id set to 0, our custom epoch 
                    // and mask configuration
                    var generator = new IdGenerator(0, epoch, mc);

                    // Let's ask the mask configuration how many generators we could instantiate 
                    // in this setup (2 bits)
                    Console.WriteLine("Max. generators       : {0}", mc.MaxGenerators);

                    // Let's ask the mask configuration how many sequential Id's we could generate 
                    // in a single ms in this setup (16 bits)
                    Console.WriteLine("Id's/ms per generator : {0}", mc.MaxSequenceIds);

                    // Let's calculate the number of Id's we could generate, per ms, should we use
                    // the maximum number of generators
                    Console.WriteLine("Id's/ms total         : {0}", mc.MaxGenerators * mc.MaxSequenceIds);

                    // Let's ask the mask configuration for how long we could generate Id's before
                    // we experience a 'wraparound' of the timestamp
                    Console.WriteLine("Wraparound interval   : {0}", mc.WraparoundInterval());

                    // And finally: let's ask the mask configuration when this wraparound will happen
                    // (we'll have to tell it the generator's epoch)
                    Console.WriteLine("Wraparound date       : {0}", mc.WraparoundDate(generator.Epoch).ToString("O"));
                }
            }
          ]]>
        </code>
        <para>Output:</para>
        <code language="none">
          <![CDATA[
            Max. generators       : 4
            Id's/ms per generator : 65536
            Id's/ms total         : 262144
            Wraparound interval   : 407226.12:41:28.8320000 (about 1114 years)
            Wraparound date       : 3130-03-13T12:41:28.8320000Z
          ]]>
        </code>
        <para>
          IdGen also provides an <codeEntityReference linkText="ITimeSource">T:IdGen.ITimeSource</codeEntityReference> interface; this can be handy for
          <externalLink>
            <linkText>unittesting</linkText>
            <linkUri>https://github.com/RobThree/IdGen/blob/master/IdGenTests/IdGenTests.cs</linkUri>
          </externalLink>
          purposes or if you want to provide a time-source for the timestamp part of your Id's that is not based on the system time. By default the <codeEntityReference linkText="IdGenerator">T:IdGen.IdGenerator</codeEntityReference> uses the <codeEntityReference linkText="DefaultTimeSource">T:IdGen.DefaultTimeSource</codeEntityReference> which, internally, simply uses <codeEntityReference linkText="DateTime.UtcNow">P:System.DateTime.UtcNow</codeEntityReference>. For unittesting we use our own
          <externalLink>
            <linkText>MockTimeSource</linkText>
            <linkUri>https://github.com/RobThree/IdGen/blob/master/IdGenTests/MockTimeSource.cs</linkUri>
          </externalLink>.
        </para>
        <para>The following constructor overloads are available:</para>
        <list class="bullet">
          <listItem>
            <para>
              <codeEntityReference linkText="IdGenerator(int generatorId)">M:IdGen.IdGenerator.#ctor(System.Int32)</codeEntityReference>
            </para>
          </listItem>
          <listItem>
            <para>
              <codeEntityReference linkText="IdGenerator(int generatorId, DateTime epoch)">M:IdGen.IdGenerator.#ctor(System.Int32,System.DateTime)</codeEntityReference>
            </para>
          </listItem>
          <listItem>
            <para>
              <codeEntityReference linkText="IdGenerator(int generatorId, DateTime epoch, MaskConfig maskConfig)">M:IdGen.IdGenerator.#ctor(System.Int32,System.DateTime,IdGen.MaskConfig)</codeEntityReference>
            </para>
          </listItem>
          <listItem>
            <para>
              <codeEntityReference linkText="IdGenerator(int generatorId, DateTime epoch, MaskConfig maskConfig, ITimeSource timeSource)">M:IdGen.IdGenerator.#ctor(System.Int32,System.DateTime,IdGen.MaskConfig,IdGen.ITimeSource)</codeEntityReference>
            </para>
          </listItem>
        </list>
        <para>
          All properties are read-only to prevent changes once an <codeEntityReference linkText="IdGenerator">T:IdGen.IdGenerator</codeEntityReference> has been instantiated.
        </para>
        <para>
          The <codeEntityReference linkText="IdGenerator">T:IdGen.IdGenerator</codeEntityReference> class provides two 'factory methods' to quickly create a <codeEntityReference linkText="machine-specific">M:IdGen.IdGenerator.GetMachineSpecificGenerator</codeEntityReference> (based on the hostname) or <codeEntityReference linkText="thread-specific">M:IdGen.IdGenerator.GetThreadSpecificGenerator</codeEntityReference> IdGenerator:
        </para>
        <code language="cs">
          <![CDATA[
          var generator = IdGenerator.GetMachineSpecificGenerator();
          ]]>
        </code>
        <para>
          or:
        </para>
        <code language="cs">
          <![CDATA[
          var generator = IdGenerator.GetThreadSpecificGenerator();
          ]]>
        </code>
        <para>
          These methods (and their overloads that allow you to specify the epoch, <codeEntityReference linkText="MaskConfig">T:IdGen.MaskConfig</codeEntityReference> and <codeEntityReference linkText="TimeSource">T:IdGen.ITimeSource</codeEntityReference>) create an <codeEntityReference linkText="IdGenerator">T:IdGen.IdGenerator</codeEntityReference> based on hostname or (managed) thread-id. However, it is recommended you explicitly set / configure a generator-id since these two methods could cause 'collisions' when machinenames' hashes result in the same id's or when thread-id's collide with thread-id's on other machines.
        </para>
      </content>
    </section>

    <relatedTopics>
      <link xlink:href="4491ec46-0001-46c1-88b7-3dd2ee8472f3" />
    </relatedTopics>
  </developerConceptualDocument>
</topic>
